package com.cybercad.billing.domain.conn.reading;

import static javax.persistence.GenerationType.IDENTITY;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

import com.cybercad.billing.domain.ReadCycle;
import com.cybercad.billing.domain.conn.Connection;

/**
 * ConnReading generated by hbm2java
 */
@Entity
@Table(name = "conn_reading", catalog = "billing")
public class ConnReading implements java.io.Serializable {

	private static final long serialVersionUID = 1L;
	private Integer id;
	private ReadCycle readCycle;
	private Connection connection;
	private Date readDate;
	private Double reading;
	private long charges;
	private long units;
	private Fault fault;

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "fault_id", nullable = false)
	public Fault getFault() {
		return this.fault;
	}

	public void setFault(Fault fault) {
		this.fault = fault;
	}

	// public long getPeriod() {
	// Date prevReadingDate =
	// connection.getConnectionStatus().getPrevReadingDate();
	// DateTime prevDate = new DateTime(prevReadingDate);
	// DateTime curDate = new DateTime(readDate);
	// return Days.daysBetween(prevDate.toLocalDate(), curDate.toLocalDate())
	// .getDays();
	// }

	public boolean isFault() {
		return null != fault;
	}

	// public long getUnits() {
	// if (isFault()) {
	// return connection.calculateMinUnits();
	// }
	// return getUnits();
	// }

	public void setUnits(long units) {
		this.units = units;
	}

	@Column(name = "charges", precision = 22, scale = 0)
	public long getCharges() {
		// final long period = getPeriod();
		// final TariffClass tariffClass = connection.getConnectionType()
		// .getTariffClass();
		// final double chargesPerDay = tariffClass
		// .getChargesPerDay(getUnitsPerDay(period));
		// charges = Math.round(chargesPerDay * period);
		return charges;
	}

	public float getUnitsPerDay(long period) {
		return units / period;
	}

	public ConnReading() {
	}

	public ConnReading(ReadCycle readCycle, Connection connection) {
		this.readCycle = readCycle;
		this.connection = connection;
	}

	public ConnReading(ReadCycle readCycle, Connection connection,
			Date readDate, Double reading, long charges) {
		this.readCycle = readCycle;
		this.connection = connection;
		this.readDate = readDate;
		this.reading = reading;
		this.charges = charges;
	}

	@Id
	@GeneratedValue(strategy = IDENTITY)
	@Column(name = "id", unique = true, nullable = false)
	public Integer getId() {
		return this.id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "read_cycle_id", nullable = false)
	public ReadCycle getReadCycle() {
		return this.readCycle;
	}

	public void setReadCycle(ReadCycle readCycle) {
		this.readCycle = readCycle;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "connection_id", nullable = false)
	public Connection getConnection() {
		return this.connection;
	}

	public void setConnection(Connection connection) {
		this.connection = connection;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "read_date", length = 19)
	public Date getReadDate() {
		return this.readDate;
	}

	public void setReadDate(Date readDate) {
		this.readDate = readDate;
	}

	@Column(name = "reading", precision = 22, scale = 0)
	public Double getReading() {
		return this.reading;
	}

	public void setReading(Double reading) {
		this.reading = reading;
	}

	public void setCharges(long charges) {
		this.charges = charges;
	}

}
